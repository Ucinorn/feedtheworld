[1mdiff --git a/index.html b/index.html[m
[1mindex cba60bc..e69de29 100644[m
[1m--- a/index.html[m
[1m+++ b/index.html[m
[36m@@ -1,130 +0,0 @@[m
[31m<!DOCTYPE html>[m
[31m<html>[m

[31m<head>[m
[31m  <title>Feed The World</title>[m
[31m  <meta name="viewport" content="width=device-width, initial-scale=1.0">[m
[31m  <link href='https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/paper/bootstrap.min.css' rel='stylesheet' type='text/css'>[m
[31m  <link href='css/main.css' rel='stylesheet' type='text/css'>[m
[31m</head>[m

[31m<body>[m
[31m  <section>[m
[31m    <button onclick="window.save()">Save</button><button onclick="window.load()">Load</button><button onclick="window.clearsave()">clear</button>[m
[31m  </section>[m
[31m  <section>[m
[31m    <div class="container">[m
[31m      <div id="nations">[m
[31m        <div rv-each-nation="nations" class='container'>[m
[31m          <span>Day: { nation.day }</span>&emsp;[m
[31m          <span>Year: { nation.year }</span>&emsp;[m
[31m          <span>Population: { nation.population | int}</span>&emsp;[m
[31m          <span>Workers: { nation.workers | int}</span>&emsp;[m
[31m          <span>Free: { nation.free | int}</span>&emsp;[m
[31m          <span>Births: { nation.births.value | int}</span>&emsp;[m
[31m          <span>Deaths: { nation.deaths.value | int}</span> &emsp;[m
[31m          <span>Research: { nation.research.value | int}</span> &emsp;[m
[31m          <span>Research Rate: { nation.research.rate | round 3} research points per person per day</span> &emsp;[m
[31m          <span>Land: { nation.land.value | round 2} km<sup>2</sup></span> &emsp;[m
[31m          <span>Water: { nation.water.value | round 2} km<sup>2</sup></span> &emsp;[m
[31m          <div class="row">[m
[31m            <div class="col-md-4">[m
[31m              <button rv-disabled="nation.exploring" rv-on-click="nation.explore">Explore</button>[m
[31m              <div rv-if="nation.exploring">[m
[31m                <progress rv-value="nation.exploretimer" rv-max="nation.exploretimermax"></progress><span>{nation.exploretimer | / nation.exploretimermax | * 100 | round }%</span>[m
[31m              </div>[m
[31m            </div>[m
[31m          </div>[m
[31m          <div class="row">[m
[31m            <div rv-each-industry="nation.industries" class=''>[m
[31m              <div rv-unless="industry.unlocked">[m
[31m                <span>Unlock { industry.name }</span>[m
[31m                <button rv-on-click="industry.unlock" rv-class-training="industry.training" rv-enabled="industry.unlockcost | lte nation.research.value">{ industry.unlockcost | int } Research</button>[m
[31m              </div>[m
[31m            </div>[m
[31m          </div>[m
[31m          <section rv-each-industry="nation.industries">[m
[31m            <div rv-if="industry.unlocked" class="row">[m
[31m              <div class='col-md-4'>[m
[31m                <h4>{ industry.name }</h4>[m
[31m                <span>{ industry.description }</span>[m
[31m                  <div rv-if="industry.trained | lt nation.population">[m
[31m                    <button rv-on-click="industry.trainworker" rv-enabled="industry.cost.value | lte nation.research.value">Train 1 worker for { industry.cost.value | int } R</button>[m
[31m                  </div>[m
[31m                  <div rv-if="industry.trained | + 10 | lte nation.population">[m
[31m                    <button rv-on-click="industry.trainworker" data-on-click="10" rv-enabled="industry.cost.value | * 10 | lte nation.research.value">Train 10 workers for { industry.cost.value | * 10 | int } R</button>[m
[31m                  </div>[m
[31m                <div rv-if="industry.training">[m
[31m                  <progress rv-value="industry.trainingcount" rv-max="industry.trainingcountmax"></progress><span>{industry.trainingcount | / industry.trainingcountmax | * 100 | round }%</span>[m
[31m                </div>[m
[31m                <div rv-if="industry.autotrain.unlocked">[m
[31m                  <label>Autotraining: <input type="checkbox" rv-checked="industry.autotrain.on"></label>[m
[31m                  <progress rv-if="industry.autotrain.on" rv-value="industry.autotrain.value" rv-max="industry.trainingtime"></progress>[m
[31m                </div>[m
[31m                <span>Training: {industry.training}</span>[m
[31m              </div>[m
[31m              <div class='col-md-4'>[m
[31m                <span>People Fed: { industry.food.rate | * industry.workers |  round 2}</span><br>[m
[31m                <span>Food Per Worker: { industry.food.rate | round 2}</span><br>[m
[31m                <span><meter rv-value="industry.workers" min="0" rv-max="nation.population">{industry.workers} out of {nation.population}</meter></span><br>[m
[31m                <span>workers: { industry.workers }</span><br>[m
[31m                <span>trained workers: { industry.trained }</span><br>[m
[31m                <span>workers capacity: { industry.maxworkers }</span><br>[m
[31m                <span>land use: { industry.landuse.rate | * industry.workers | round 2} km<sup>2</sup> ({industry.landuse.rate | * industry.workers | / nation.land.value | * 100 | round 2}% )</span><br>[m
[31m                <span rv-if="industry.wateruse.rate | * industry.workers | > 1">water use: { industry.wateruse.rate | * industry.workers | round 2} km<sup>2</sup> ({industry.wateruse.rate | * industry.workers | / nation.water.value | * 100 | round 2}% )</span><br>[m
[31m                <span>limiting factor: { industry.limiter }</span><br>[m
[31m              </div>[m
[31m              <div rv-each-upgrade="nation.upgrades" class='col-md-4'>[m
[31m                <div rv-if="upgrade.industry | like industry.name">[m
[31m                  <button rv-on-click="upgrade.buy" rv-if="upgrade.unlocked" rv-enabled="upgrade.cost.value | lte nation.research.value | and upgrade.buyable" rv-class-bought="upgrade.count | gte upgrade.max">[m
[31m                                                { upgrade.name } <span rv-if='upgrade.count | gt 1'>{ upgrade.count }</span> : { upgrade.cost.value | int } R <span rv-if="upgrade.cost.multiplier | gt 1">( {upgrade.cost.multiplier | * 100 | round 2}%) </span>[m
[31m                                            </button>[m
[31m                  <div class='toolcontainer'>[m
[31m                    <div class='tooltip'>[m
[31m                      <span>{ upgrade.description }</span><br>[m
[31m                      <span>{ upgrade.effects }</span><br>[m
[31m                      <span>Cost: { upgrade.cost.value | int }</span><br>[m
[31m                      <span rv-if="upgrade.count | gte 1">Bought { upgrade.count } of {upgrade.max}</span><br>[m
[31m                      <span>buyable?: { upgrade.buyable }</span><br>[m
[31m                      <span>unlocked?: { upgrade.unlocked }</span><br>[m
[31m                    </div>[m
[31m                  </div>[m

[31m                </div>[m
[31m              </div>[m
[31m            </div>[m
[31m          </section>[m
[31m          <section>[m
[31m            <h2>Other</h2>[m
[31m            <div rv-each-upgrade="nation.upgrades" class='two columns'>[m
[31m              <div rv-if="upgrade.industry | isEmpty">[m
[31m                <div rv-if="upgrade.unlocked">[m
[31m                  <h4>{ upgrade.name }</h4>[m
[31m                  <button rv-on-click="upgrade.buy" rv-enabled="upgrade.cost.value | lte nation.research.value | and upgrade.buyable">Buy for { upgrade.cost.value | int }</button><br>[m
[31m                  <span>{ upgrade.description }</span><br><br>[m
[31m                  <span>Effects: { upgrade.effects }</span><br>[m
[31m                  <span>Cost: { upgrade.cost.value | int }</span><br>[m
[31m                  <span>Count: { upgrade.count }</span><br>[m
[31m                </div>[m
[31m              </div>[m
[31m          </section>[m
[31m          </div>[m
[31m  </section>[m
[31m  </div>[m
[31m  </div>[m
[31m  </section>[m
[31m  <footer>[m

[31m    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>[m
[31m    <script src="vendor/scripts/rivets.bundled.min.js"></script>[m
[31m    <script src="vendor/scripts/store.min.js"></script>[m
[31m    <script src="vendor/scripts/watch.min.js"></script>[m
[31m    <script src="js/rivetsoptions.js"></script>[m
[31m    <script src="js/app.js"></script>[m
[31m    <script src="js/industries.js"></script>[m
[31m    <script src="js/upgrades.js"></script>[m
[31m    <script src="js/init.js"></script>[m
[31m  </footer>[m
[31m</body>[m

[31m</html>[m
[1mdiff --git a/js/app.js b/js/app.js[m
[1mindex 1f2161a..e69de29 100644[m
[1m--- a/js/app.js[m
[1m+++ b/js/app.js[m
[36m@@ -1,560 +0,0 @@[m
[31mfunction fetch(container, name) {[m
[31m  for (var i = 0; i < container.length; i++) {[m
[31m    if (container[i].name == name)[m
[31m      return container[i];[m
[31m  }[m
[31m}[m

[31mfunction round(x, digits) {[m
[31m  if (digits) {[m
[31m    return parseFloat(x.toFixed(digits));[m
[31m  } else {[m
[31m    return parseFloat(x.toFixed(2));[m
[31m  }[m
[31m}[m

[31m// be very careful with this!!![m
[31mfunction boundeval(currentvalue, index, array) {[m
[31m  return eval(currentvalue);[m
[31m}[m

[31m// Monkey-patch functions passed to all models. [m
[31m// The init() function is sacred and is ignored.[m
[31mfunction monkeypatch(atts, init) {[m
[31m  if (atts instanceof Object) {[m
[31m    for (var key in atts) {[m
[31m      if (typeof(atts[key]) === 'function' && key !== 'init') {[m
[31m        // monkey patch new function to old function.[m
[31m        var oldfunction = this[key];[m
[31m        var newfunction = atts[key];[m
[31m        // no arguments passed but we can use .arguments to pass them in future if we need to[m
[31m        this[key] = function() {[m
[31m          oldfunction.apply(this);[m
[31m          newfunction.apply(this);[m
[31m        }.bind(this);[m
[31m      }[m
[31m    }[m
[31m  }[m
[31m}[m

[31m// a simple model that stores a value, but can be effected by multipliers.[m
[31mvar val = function val(attributes) {[m
[31m  this.value = 1;[m
[31m  this.base = 1;[m
[31m  this.rate = 1;[m
[31m  this.multiplier = 1;[m
[31m  this.multis = {[m
[31m    'base': [1][m
[31m  };[m

[31m  //initialisation script. This pulls any function passed when the models are built. [m
[31m  if (typeof attributes == 'object' && typeof attributes.init == 'function') {[m
[31m    attributes.init.apply(this);[m
[31m    this.firstbase = this.base;[m
[31m  }[m

[31m  // refresh multipliers when rates and multipliers change. This should be called in the helper function below[m
[31m  this.refresh = function() {[m
[31m    var multiplier = 0;[m
[31m    for (var multi in this.multis) {[m
[31m      // Each multiplier group is added to each other[m
[31m      // The base multiplier is ADDITIVE, ie. each multiplier is added together[m
[31m      // All named multipliers are CUMULATIVE, ie. each muiltiplier is multiplied by the next one[m
[31m        if (multi === 'base') {[m
[31m          multiplier += this.multis[multi].reduce(function(a, b) {[m
[31m            return a + b;[m
[31m          });[m
[31m        } else {[m
[31m          multiplier += this.multis[multi].reduce(function(a, b) {[m
[31m            // add 1 to the second multiplier to ensure it acts as a percentage for calculation[m
[31m            // this is beacsue all multiplier are supplied as decimals ie. 0.1 or 2.4 equals 10% or 240%[m
[31m            return round(a * (1 + b));[m
[31m          });[m
[31m        }[m
[31m        this.multiplier = multiplier;[m
[31m        this.value = +(this.base * this.multiplier);[m
[31m      // this might seem unnessesary but some legacy fnction use rate as the value. [m
[31m      // Hangover from when val() and res() where one model[m
[31m        this.rate = this.value;[m
[31m    }[m
[31m  }[m

[31m    //add a generic base multipler or name it if you want to remove or modify it late[m
[31m    // the base group is ADDITIVE, ie.( 1 + 0.1 + 0.2 = 130% )[m
[31m    // any NAMED groups are cumulative ie.( 1 * 0.1 * 0.2 = 132% )[m
[31m    // All groups are added up [m
[31m    this.addmulti = function(amount, name) {[m
[31m      if (amount !== undefined) {[m
[31m        if (name === undefined) {[m
[31m          console.log('Applying multiplier to base')[m
[31m          this.multis.base.push(amount);[m
[31m        } else {[m
[31m          console.log('Applying cumulative named multipler: ' + name)[m
[31m          if (this.multis[name]) {[m
[31m            this.multis[name].push(amount);[m
[31m          } else {[m
[31m            this.multis[name] = [amount];[m
[31m          }[m
[31m        }[m
[31m      } else {[m
[31m        console.log('attempted to apply a multiplier without an amount!')[m
[31m      }[m
[31m      this.refresh.apply(this);[m
[31m    }[m

[31m    this.refresh.apply(this);[m

[31m    //monkey patch all other functions[m
[31m    monkeypatch.apply(this, [attributes]);[m

[31m  }.bind(this);[m


[31mvar res = function res(attributes) {[m
[31m  this.value = 0;[m
[31m  this.base = 1;[m
[31m  this.multiplier = 1;[m
[31m  this.rate = 1;[m
[31m  this.multis = {[m
[31m    'base': [1][m
[31m  };[m

[31m  //initialisation script. This pulls any function passed when the models are built. [m
[31m  if (typeof attributes == 'object' && typeof attributes.init == 'function') {[m
[31m    attributes.init.apply(this);[m
[31m    this.firstbase = this.base[m
[31m  }[m

[31m  // refresh multipliers when rates and multipliers change. This should be called in the helper function below[m
[31m  this.refresh = function() {[m
[31m    var multigroup = [];[m
[31m    for (var multi in this.multis) {[m
[31m      multigroup.push(this.multis[multi].reduce(function(a, b) {[m
[31m        return a + b;[m
[31m      }));[m
[31m    }[m
[31m    this.multiplier = multigroup.reduce(function(a, b) {[m
[31m      return a + b;[m
[31m    });[m
[31m    this.rate = +(this.base * this.multiplier);[m
[31m  }[m

[31m  //add a generic base multipler or name it if you want to remove or modify it late[m
[31m  // the base group is ADDITIVE, ie.( 1 + 0.1 + 0.2 = 130% )[m
[31m  // any NAMED groups are cumulative ie.( 1 * 0.1 * 0.2 = 132% )[m
[31m  // All groups are added up [m
[31m  this.addmulti = function(amount, name) {[m
[31m    if (amount !== undefined) {[m
[31m      if (name === undefined) {[m
[31m        console.log('Applying multiplier to base')[m
[31m        this.multis.base.push(amount);[m
[31m      } else {[m
[31m        console.log('Applying cumulative named multipler: ' + name)[m
[31m        if (this.multis[name]) {[m
[31m          this.multis[name].push(amount);[m
[31m        } else {[m
[31m          this.multis[name] = [amount];[m
[31m        }[m
[31m      }[m
[31m    } else {[m
[31m      console.log('attempted to apply a multiplier without an amount!')[m
[31m    }[m
[31m    this.refresh.apply(this);[m
[31m  }[m

[31m  this.inc = function(amount) {[m
[31m    if (typeof amount === 'number') {[m
[31m      this.value += +(amount * this.rate);[m
[31m    } else {[m
[31m      this.value += this.rate;[m
[31m    }[m
[31m  }[m

[31m  this.take = function(amount) {[m
[31m    if (amount === undefined) {[m
[31m      this.value--;[m
[31m    } else if (amount > 0) {[m
[31m      this.value -= amount;[m
[31m    }[m
[31m  }[m

[31m  this.refresh.apply(this);[m

[31m  //monkey patch all other functions[m
[31m  monkeypatch.apply(this, [attributes]);[m
[31m}.bind(this);[m

[31mvar nation_model = function nation_model(attributes) {[m

[31m  //static attributes[m
[31m  this.day = 0;[m
[31m  this.dayrate = 1; // Increase this to increase the number of days per tick. Just remember to [m
[31m  this.daysSinceUpdate = 0;[m
[31m  this.dayspersecond = 50;[m
[31m  this.year = 0;[m
[31m  this.yearlength = 365;[m
[31m  this.name = '';[m
[31m  // discovered biomes, animals, plants and features. As your nation grows, you will gain access to these through exploration, unlocks and [m
[31m  this.discoveries = {[m
[31m    ocean: false,[m
[31m    river: false,[m
[31m    mountains: false,[m
[31m    tundra: false,[m
[31m    arctic: false,[m
[31m    wheat: false,[m
[31m    dogs: false,[m
[31m    cows: false,[m
[31m    horses: false,[m
[31m  }[m

[31m  this.population = 1;[m
[31m  // the amount of people capable of working in the food production industry. This starts very high; almost all people work from the age of 5 to their death at 40[m
[31m  // this gradually reduces as childhood is invented and education becomes standardised. [m
[31m  this.participation = 0.95;[m
[31m  // the missing value is used for things like exploration where people leave and come back. [m
[31m  this.missing = 0;[m
[31m  // the base population growth rate for most of history was 0.05%. it peaked in the 70s at 2% and now rests around 1.1%[m
[31m  this.births = new res({[m
[31m    init: function() {[m
[31m      this.base = 0.045; // 45 births per thousand people per year, or a population growth rate of 4.5%. 4.5% is pretty much constant breeding from puberty till death at 35. Modern nations end up around 1.0% or lower.[m
[31m    }[m
[31m  });[m
[31m  this.deaths = new res({[m
[31m    init: function() {[m
[31m      this.base = 0.044; // 44 deaths per thousand PEOPLE per year or a population growth rate of -4.4%. This is very high in early history, but reduces dramtically to less than 0.7% as food is plentiful[m
[31m    }[m
[31m  });[m
[31m  this.land = new res({[m
[31m    init: function() {[m
[31m      this.value = 10000; // Usable land in square kilometres. Currently the size of a small valley nation. This is enough for nomadic tribes, but becomes a bottleneck as population grows. [m
[31m      this.base = 100; // the basic increase in land from exploration in suqare kilometres[m
[31m    }[m
[31m  });[m
[31m  this.water = new res({[m
[31m    init: function() {[m
[31m      this.value = 1000; // Usable water in square kilometres. Currently the size of a small bay. Not all water is fertile or traversable, and better technology vastly improves this.  [m
[31m      this.base = 10; // the basic increase in water from exploration in suqare kilometres[m
[31m    }[m
[31m  });[m
[31m  this.research = new res({[m
[31m    init: function() {[m
[31m      this.value = 2000;[m
[31m      this.base = 0.01;[m
[31m    }[m
[31m  });[m

[31m  this.industries = []; // container for industry models[m
[31m  this.upgrades = []; // container for upgrades models[m

[31m  //init[m
[31m  if (attributes.init) {[m
[31m    attributes.init.apply(this);[m
[31m  }[m

[31m  // Put anything that must happen on a static interval here. [m
[31m  // Good for anything that needs to be updated but not in real-time, like seasons, population and years. [m
[31m  this.update = function() {[m
[31m    this.year = parseInt(Math.floor(this.day / this.yearlength));[m
[31m    // tick births and deaths based on the current population[m
[31m    // important to divide by the year, or every person would be firing out a baby every day[m
[31m    // then divide by the days that have passed because updates are slower than days. [m
[31m    var birthssince = +(this.daysSinceUpdate * (this.population / this.yearlength));[m
[31m    this.births.inc(birthssince);[m
[31m    this.deaths.inc(birthssince);[m
[31m    this.population = this.births.value - this.deaths.value - this.missing;[m
[31m    this.lastupdate = this.day;[m

[31m    // Set workers up from the national level, becasue they all come from the same population pool. [m
[31m    // The list is sorted down below, so this loop always works from most to least productive. [m
[31m    var pop_pool = round(this.population * this.participation);[m
[31m    var food_pool = this.population;[m
[31m    var land_pool = this.land.value;[m
[31m    var water_pool = this.water.value;[m
[31m    this.industries.forEach(function(i) {[m
[31m      if (i.unlocked === true) {[m
[31m        var food_poss = parseInt(i.trained * parseFloat(i.food.rate));[m
[31m        var land_poss = parseInt(i.trained * parseFloat(i.landuse.rate));[m
[31m        var water_poss = parseInt(i.trained * parseFloat(i.landuse.rate));[m
[31m        var limits = [];[m

[31m        // There is always a hard limit of how many workers there are[m
[31m        // by dividing the total resources by the production rate per person we get [m
[31m        // the total number of workers required to use 100% of he remaining resources [m
[31m        limits['No more trained workers available'] = i.trained;[m
[31m        limits['Other industries are supplying sufficient food'] = parseInt(food_pool / i.food.rate);[m
[31m        limits['All arable land is being used'] = parseInt(land_pool / i.landuse.rate);[m
[31m        limits['All fishable water is being used'] = parseInt(water_pool / i.wateruse.rate);[m
[31m      [m
[31m        // Run through the limiting factors for workers and return the lowest amount. [m
[31m        // This is the max number of workers an industry can have, due to any factor[m
[31m        var minimum = Infinity;[m
[31m        for (var x in limits) {[m
[31m          if (limits[x] < minimum) {[m
[31m            minimum = limits[x];[m
[31m            i.limiter = x;[m
[31m          }[m
[31m        }[m
[31m        i.maxworkers = minimum;[m
[31m        if (pop_pool > i.maxworkers) {[m
[31m          i.workers = Math.round(i.maxworkers);[m
[31m        } else {[m
[31m          i.workers = Math.round(pop_pool);[m
[31m        }[m

[31m        // reduce the pools of resources becasue thsi industry now has a worker value. [m
[31m        food_pool -= parseInt(i.workers * i.food.rate);[m
[31m        land_pool -= parseInt(i.workers * i.landuse.rate);        [m
[31m        water_pool -= parseInt(i.workers * i.wateruse.rate);[m
[31m        pop_pool -= parseInt(i.workers);[m
[31m        [m
[31m        // move on and see if workers in any other industries are neccessary[m
[31m      }[m
[31m    });[m
[31m    this.free = pop_pool;[m
[31m    this.workers = this.population - this.free;[m

[31m    //  update the nation's child objects[m
[31m    this.industries.forEach(function(model) {[m
[31m      model.update();[m
[31m    });[m
[31m    this.upgrades.forEach(function(model) {[m
[31m      model.update();[m
[31m    });[m

[31m    // sort industries so that workers go to the most productive industries first [m
[31m    this.industries.sort(function(a, b) {[m
[31m      return +(b.food.rate - a.food.rate);[m
[31m    })[m

[31m    // reset the days since the last update[m
[31m    this.daysSinceUpdate = 0;[m

[31m  }.bind(this);[m

[31m  // Put anything that must happen on a variable interval here.[m
[31m  this.tick = function() {[m
[31m    this.day += this.dayrate;[m
[31m    this.daysSinceUpdate += this.dayrate;[m

[31m    this.explorecheck();[m

[31m    // increase research based on current free workers[m
[31m    var researchers = round(this.free * this.dayrate);[m
[31m    if (researchers > 1) {[m
[31m      this.research.inc(researchers);[m
[31m    }[m
[31m    // tick the nation's child objects[m
[31m    this.industries.forEach(function(model) {[m
[31m      model.tick();[m
[31m    });[m
[31m    this.upgrades.forEach(function(model) {[m
[31m      model.tick();[m
[31m    });[m
[31m  }.bind(this);[m

[31m  this.explore = function() {[m
[31m    // reduce population by whatever is larger:  50 free workers or 10% of free workers[m
[31m    console.log('Exploring for a year');[m
[31m    if (parseInt(this.free * 0.1) > 50) {[m
[31m      this.missing = parseInt(this.free * 0.1)[m
[31m    } else {[m
[31m      this.missing = 50;[m
[31m    }[m
[31m    this.exploring = true;[m
[31m    this.exploretimer = this.yearlength;[m
[31m    this.exploretimermax = this.yearlength;[m
[31m  }.bind(this);[m

[31m  this.explorecheck = function() {[m
[31m    if (this.exploring) {[m
[31m      if (this.exploretimer > 0) {[m
[31m        this.exploretimer--;[m
[31m      } else {[m
[31m        // returned land is equal to the number of explorers with a 20% variance, positve or negative.[m
[31m        this.land.inc(this.missing * (1 + (( Math.random() - 0.5 ) * 0.2 ) ));[m
[31m        console.log('Finished exploring, found land: ' + this.missing);[m
[31m        this.missing = 0;[m
[31m        this.exploretimer = 0;[m
[31m        this.exploring = false;[m
[31m      }[m
[31m    }[m
[31m  }.bind(this);[m

[31m  //overwrite default functions if they are supplied to the constructor[m
[31m  monkeypatch.apply(this, [attributes]);[m

[31m};[m

[31mvar industry_model = function industry_model(attributes) {[m

[31m  // Default attributes[m
[31m  this.name = '';[m
[31m  this.parent = '';[m
[31m  this.category = '';[m
[31m  this.unlocked = false;[m
[31m  this.unlockcost = 100;[m
[31m  // a food ratio of 1 means one person working provides enough for one person. One person consumes one unit of food per day.[m
[31m  this.food = new val();[m
[31m  // the cost multipler of the industry [m
[31m  this.cost = new val();[m
[31m  // the amount of workers in the industry. This is automatically set. [m
[31m  this.workers = 0;[m
[31m  // the amount of land in square kms required for a single worker to produce food.[m
[31m  this.landuse = new val();[m

[31m  // the amount of water required for a single worker to produce food.[m
[31m  this.wateruse = new val({[m
[31m    base: 0,[m
[31m  });[m
[31m  // the trained workers in an industry. This can be more or less than the current number of workers, and be a limiting factor on the maximum amount of possible workers.[m
[31m  this.trained = 0;[m
[31m  this.training = false;[m
[31m  this.trainingtime = 30; // in days (ticks)[m

[31m  this.autotrain = {};[m
[31m  this.autotrain.unlocked = false //unlock autotraining for the industry[m
[31m  this.autotrain.on = false; // flag to start autotraining[m
[31m  this.autotrain.rate = 1; //the number of research points that can be used to autotrain workers[m
[31m  this.autotrain.value = 1; //a ticker that counts down up to the cost of training[m
[31m  this.autotrain.amount = 1; //the number of students to autotrain at one time[m

[31m  //init[m
[31m  if (attributes.init) {[m
[31m    attributes.init.apply(this);[m
[31m  }[m


[31m  //Put anything that must happen on a static, longer interval here. [m
[31m  this.update = function() {[m

[31m  };[m

[31m  //Put anything that must happen on a dynamic interval here. Try and avoid for industries, it could get out of hand. [m
[31m  this.tick = function() {[m
[31m    this.traincheck();[m
[31m  };[m

[31m  this.unlock = function(amount) {[m
[31m    amount = (typeof amount != "undefined") ? amount : this.unlockcost;[m
[31m    if (this.parentobject.research.value < amount) {[m
[31m      console.log('Attempted to spend more than you have on an upgrade. Please validate buy buttons correctly');[m
[31m      return;[m
[31m    }[m
[31m    this.parentobject.research.take(amount);[m
[31m    this.unlocked = true;[m
[31m    this.unlocktime = Date.now();[m
[31m  }.bind(this);[m

[31m  this.traincheck = function() {[m
[31m    // if training is happening, Tick down till it is complete. [m
[31m    // Otherwise autotraining things happen if they are unlocked and enabled[m
[31m    if (this.training) {[m
[31m      if (this.trainingcount > 0) {[m
[31m        this.trainingcount--;[m
[31m      } else {[m
[31m        this.trainingcomplete();[m
[31m      }[m
[31m    } else if (this.autotrain.unlocked && this.autotrain.on && this.trained <= this.parentobject.population) {[m
[31m      // the autotrain counter goes [m
[31m      // increment the training counter if its less than the training time, otherwise just train a worker.[m
[31m        if (this.autotrain.value <= this.trainingtime) {[m
[31m          this.autotrain.value += this.autotrain.rate;[m
[31m        } else {[m
[31m          this.trainworker(this.autotrain.amount);[m
[31m          this.autotrain.value = 0;[m
[31m        }[m
[31m      }[m
[31m  }[m

[31m  this.trainworker = function(amount) {[m
[31m    console.log('training worker');[m
[31m    this.training = true;[m
[31m    // calling the function without an amount creates only one worker[m
[31m    amount = (amount > 1) ? amount : 1;[m
[31m    // set the cost to 0 if training is automatic[m
[31m    var cost = (this.autotrain.value > 1) ? 0 : this.cost.value;[m
[31m    this.parentobject.research.take(Math.floor(parseInt(cost) * amount));[m
[31m    this.training = true;[m
[31m    this.trainingamount = amount;[m
[31m    // TODO - apply a better logarithmic scale to this equation so higher class sizes = quicker training.[m
[31m    this.trainingcount = Math.floor(this.trainingtime * (amount * (amount / Math.pow(amount, 1.2))));[m
[31m    // this might look weird, but training count is incremented down elsewhere. [m
[31m    this.trainingcountmax = this.trainingcount;[m
[31m  }.bind(this);[m


[31m  this.trainingcomplete = function() {[m
[31m    this.trained = +(this.trained) + Math.round((this.trainingamount > 1 ? this.trainingamount : 1), 0);[m
[31m    this.training = false;[m
[31m    this.trainingcount = 0;[m
[31m  };[m

[31m  this.parentobject = fetch(nations, this.parent);[m

[31m  monkeypatch.apply(this, [attributes]);[m

[31m};[m

[31mvar upgrade_model = function upgrade_model(attributes) {[m

[31m  // Default attributes[m
[31m  this.name = 'Default Name';[m
[31m  this.description = 'Default Description';[m
[31m  this.effects = 'Effects';[m
[31m  this.category = '';[m
[31m  this.count = 0;[m
[31m  this.max = 1;[m
[31m  this.cost = new val();[m
[31m  this.specialty = false;[m
[31m  this.buyable = true;[m
[31m  this.self = this;[m
[31m  this.timer = 0;[m

[31m  //init[m
[31m  if (attributes.init) {[m
[31m    attributes.init.apply(this);[m
[31m  }[m

[31m  //Put anything that must happen on a dynamic interval here. It can be called individually or at intervals by the parent model[m
[31m  this.tick = function() {[m

[31m  };[m

[31m  //Put anything that must happen on a static, longer interval here. It can be called individually or at intervals by the parent model. [m
[31m  this.update = function() {[m
[31m    if (this.unlockconditions) {[m
[31m      if (this.unlocked === false) {[m
[31m        //the .every() function here returns true if all unlock conditions are true[m
[31m        this.unlocked = this.unlockconditions.every(boundeval, this);[m
[31m      }[m
[31m    }[m
[31m  };[m


[31m  this.buy = function(val) {[m

[31m    amount = (typeof amount != "undefined") ? val : this.cost.value;[m

[31m    if (this.parentobject.research.value < amount) {[m
[31m      console.log('Attempted to spend more than you have. Please validate buy buttons correctly');[m
[31m      return;[m
[31m    }[m
[31m    this.buyable = false;[m
[31m    if (this.count < this.max) {[m
[31m      this.count++;[m
[31m    }[m
[31m    // this looks redundant, but we need to repeat the check becasue the count may have gone up to equal the max. if it has, the upgrade is no longer buyable[m
[31m    if (this.count < this.max) {[m
[31m      this.buyable = true;[m
[31m    }[m
[31m    this.parentobject.research.take(amount);[m
[31m  };[m

[31m  this.parentobject = fetch(nations, this.parent)[m
[31m  if (this.industry !== '') {[m
[31m    this.industryobject = fetch(this.parentobject.industries, this.industry);[m
[31m  }[m

[31m  //overwrite default functions if they are supplied to the constructor[m
[31m  monkeypatch.apply(this, [attributes]);[m
[31m}.bind(this);[m
